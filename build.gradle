title = "Qi4j SDK"
description = "Qi4jâ„¢ is a framework for domain centric application development, including evolved concepts from AOP, DI and DDD."

apply plugin: 'java'
apply from: 'maven-compat.gradle'
apply plugin: 'project-report'

// Versions of Dependencies;
asmVersion = '3.3'
bouncyVersion = '1.45'
googleCollectionsVersion = '1.0'
jdbmVersion = '1.0'
jettyVersion = '6.1.22'
jodaTimeVersion = '1.6.2'
log4jVersion = '1.2.16'
osgiVersion = '4.2.0'
rdfVersion = '2.3.2'
restletVersion = '2.0.4'
servletVersion = '2.5'
shiroVersion = '1.1.0'
sleepycatVersion = '4.0.103'
slf4jVersion = '1.6.1'
solrVersion = "1.4.1"
springVersion = '2.5.6'
strutsVersion = '2.1.8.1'
vaadinVersion = '6.4.8'
voldemortVersion = '0.81'

antVersion = '1.8.1'
junitVersion = '4.8.1'
testNgVersion = '5.8'
jmockVersion = '2.5.1'
mockitoVersion = '1.8.5'
easyMockVersion = '3.0'

targetCompatibility = "1.6"
sourceCompatibility = "1.6"

testFailures = false

allprojects {
  apply plugin: 'eclipse'
  apply plugin: 'idea'
  apply plugin: 'java'
  apply plugin: 'code-quality'
  apply plugin: 'project-report'

  group = name.substring(0, name.lastIndexOf('.'))
  defaultTasks 'build'
  version = System.properties.version ?: "0"
  idea.javaVersion = '1.6'
  [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

  repositories {
    mavenCentral()
    mavenRepo name: 'ops4j-repo', urls: "http://repository.ops4j.org/maven2/"
  }

  dependencies {
    testCompile("org.apache.ant:ant:$antVersion")
    testCompile("org.apache.ant:ant-junit:$antVersion")
    testCompile('junit:junit:4.8.1')
    testRuntime('net.sourceforge.cobertura:cobertura:1.9.3')
    testRuntime("asm:asm:$asmVersion", "asm:asm-util:$asmVersion", "asm:asm-commons:$asmVersion")
  }

  configurations {
    deployerJars
  }

  dependencies {
    deployerJars "org.apache.maven.wagon:wagon-ssh:1.0-beta-2"
  }

  javaDir = new File("$projectDir/src/main/java")
  testDir = new File("$projectDir/src/test/java")

  if( javaDir.isDirectory() || testDir.isDirectory() )
  {
    apply plugin: 'osgi'
    apply plugin: VersionClass
    apply plugin: 'code-quality'

    if( name == "org.qi4j.core.runtime" )
    {
      checkstyleMain {
        configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-runtime-checkstyle.xml")
        ignoreFailures = true
      }
    }
    else
    {
      checkstyleMain {
        configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-api-checkstyle.xml")
        ignoreFailures = true
      }
    }
    checkstyleTest {
      configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-tests-checkstyle.xml")
      ignoreFailures = true
    }

    checkstyleVersion {
      configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-tests-checkstyle.xml")
      ignoreFailures = true
    }

    jar {
      manifest {
        symbolicName = project.name
        license = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
        docURL = 'http://www.qi4j.org'
        description = 'Qi4j is a platform for Composite Oriented Programming'
        vendor = 'Qi4j Community, http://www.qi4j.org'
        instruction '-debug', 'true'
      }
    }

    def cobSerFile = "${project.buildDir}/coverage/cobertura.ser"
    def srcOriginal = "${sourceSets.main.classesDir}"
    def srcCopy = "${srcOriginal}-copy"

    test.doFirst {
      ant {
        // delete data file for cobertura, otherwise coverage would be added
        delete(file: cobSerFile, failonerror: false)
        // delete copy of original classes
        delete(dir: srcCopy, failonerror: false)
        // import cobertura task, so it is available in the script
        taskdef(resource: 'tasks.properties', classpath: configurations.testRuntime.asPath)
        // create copy (backup) of original class files
        copy(todir: srcCopy) {
          fileset(dir: srcOriginal)
        }
        // instrument the relevant classes in-place
        'cobertura-instrument'(datafile: cobSerFile) {
          fileset(dir: srcOriginal,
                  includes: "org/qi4j/**/*.class",
                  excludes: "**/*Test.class")
        }
      }
    }

    test.doLast {
      if( new File(srcCopy).exists() )
      {
        def gradleProject = project
        def rootCobSerFile = "${rootProject.buildDir}/coverage/cobertura.ser"

        // replace instrumented classes with backup copy again
        ant {
          delete(file: srcOriginal)
          move(file: srcCopy, tofile: srcOriginal)

          taskdef(name: 'coberturaMerge',
                  classname: 'net.sourceforge.cobertura.ant.MergeTask',
                  classpath: configurations.testRuntime.asPath)

          coberturaMerge(datafile: rootCobSerFile) {

            if( file("${gradleProject.buildDir}/coverage/cobertura.ser").exists() )
            {

              fileset(dir: gradleProject.buildDir, includes: 'coverage/cobertura.ser')
            }
          }
        }
      }
    }

    def testProperties = [
            'proxySet': System.properties[ 'proxySet' ],
            'proxyHost': System.properties[ 'proxyHost' ],
            'proxyPort': System.properties[ 'proxyPort' ]]

    test {
      maxHeapSize = "1024m"
      systemProperties = testProperties
      systemProperties[ "net.sourceforge.cobertura.datafile" ] = cobSerFile
      ignoreFailures = true
      afterSuite { descriptor, result ->
        if( result.testCount != result.successfulTestCount )
        {
          rootProject.testFailures = true
        }
      }
    }

    // Create checkstyle report
//    task checkstyleReport(type: Xslt, dependsOn: check) {
//      source project.checkstyleResultsDir
//      include '*.xml'
//      destDir = project.checkstyleResultsDir
//      extension = 'html'
//      stylesheetFile = file('etc/checkstyle-frames.xsl')
//    }

  }


  uploadArchives.doFirst {
    if( System.properties[ 'version' ] == null )
    {
      throw new GradleException("'version' must be given as a system property to perform a release.")
    }
  }

  uploadArchives {
    repositories.mavenDeployer {
      configuration = configurations.deployerJars
      repository(url: "file://localhost/$rootProject.buildDir/repository/")
    }
    repositories.mavenDeployer {
      name = 'sshDeployer' // optional
      configuration = configurations.deployerJars
      repository(url: "scp://repository.ops4j.org/home/www/repository.ops4j.org/maven2/")
    }
  }

  ideaModule {
    whenConfigured { module ->
      module.dependencies*.exported = true
    }
  }


  dependsOnChildren()
}

// build a map of the dependency artifacts to use.  Allows centralized definition of the version of artifacts to
// use.  In that respect it serves a role similar to <dependencyManagement> in Maven

libraries = [
        // Ant
        ant: "org.apache.ant:ant:$antVersion",

        // ASM
        asm: "asm:asm:$asmVersion",
        asm_util: "asm:asm-util:$asmVersion",
        asm_commons: "asm:asm-commons:$asmVersion",

        // OSGi
        osgi_core: "org.osgi:org.osgi.core:$osgiVersion",
        osgi_compendium: "org.osgi:org.osgi.compendium:$osgiVersion",
        osgi_enterprise: "org.osgi:org.osgi.enterprise:$osgiVersion",

        // logging
        slf4j_api: "org.slf4j:slf4j-api:$slf4jVersion",
        slf4j_simple: "org.slf4j:slf4j-simple:$slf4jVersion",
        jcl_slf4j: "org.slf4j:jcl-over-slf4j:$slf4jVersion",
        jcl_api: 'commons-logging:commons-logging-api:99.0-does-not-exist',  //ensure it is never used.
        jcl: 'commons-logging:commons-logging:99.0-does-not-exist',  // ensure it is never used.

        // testing
        junit: "junit:junit:$junitVersion",
        easymock: "org.easymock:easymock:$easyMockVersion",
        mockito: "org.mockito:mockito-core:$mockitoVersion",
        jmock: "org.jmock:jmock:$jmockVersion",
        testng: "org.testng:testng:$testNgVersion:jdk15"
]

test.doLast() {
//task genReport {
  def cobSerFile = "${project.buildDir}/coverage/cobertura.ser"
  ant {
    taskdef(name: 'coberturaReport',
            classname: 'net.sourceforge.cobertura.ant.ReportTask',
            classpath: configurations.testRuntime.asPath)

    // create cobertura report
    coberturaReport(destdir: buildDirName + "/reports/cobertura", format: 'html', datafile: cobSerFile) {
      allprojects.each { module ->
        if( rootProject != module )
        {
          if( file("$module.projectDir.absolutePath/src/main/java").exists() )
          {
            fileset(dir: "$module.projectDir.absolutePath/src/main/java") {
              include(name: '**/*.java')
            }
          }
        }
      }
    }

    taskdef(name: 'junitreport',
            classname: 'org.apache.tools.ant.taskdefs.optional.junit.XMLResultAggregator',
            classpath: configurations.testRuntime.asPath)

    // create Junit report
    def junitReportDir = buildDirName + "/reports/junit"
    mkdir(dir: junitReportDir)
    mkdir(dir: buildDirName + "/test-results")
    junitreport(todir: junitReportDir) {
      report(format: 'frames', todir: junitReportDir)
      allprojects.each { module ->
        fileset(dir: "$module.buildDir/test-results") {
          include(name: "TEST-*.xml")
        }
      }
    }

  }
}

task javadocs(type: Javadoc) {

  doLast {
    options.docFilesSubDirs = true
    title = "${rootProject.title} ${version}"
    def apiSources = subprojects.findAll({ project -> project.name != 'runtime' })
    source apiSources.collect { project ->
      project.sourceSets.main.allJava
    }
    destinationDir = new File("$buildDir/javadocs")
    // Might need a classpath
    classpath = files(apiSources.collect { project ->
      project.sourceSets.main.compileClasspath
    })
    options.links("http://java.sun.com/j2se/1.6.0/docs/api")
    options.group(["Core API": ["org.qi4j.core.api.*"],
                  "Core SPI": ["org.qi4j.core.spi.*"],
                  "Core Bootstrap": ["org.qi4j.core.bootstrap.*"]
                  ])
  }
}

task distLayout {
  srcDistImage = copySpec {
    from '.'
    exclude '**/build/'     // build output
    exclude '**/.git/'      // git directories
    exclude '**/.git*'      // git files
    exclude '**/.gradle/'   // gradle management files
    into "qi4j-sdk-$version/src/"
  }


  docsImage = copySpec {
    into("docs")
    from "$buildDir/docs"
  }
  reportsImage = copySpec {
    into("docs/reports")
    from "$buildDir/reports"
  }
  javadocsImage = copySpec {
    into("javadocs")
    from "$buildDir/javadocs"
  }
  libsImage = copySpec {
    allprojects.each { project ->
      if( project.group == 'org.qi4j.core' )
      {
        from project.configurations.runtime
        into("libs/core")
      }
      else if( project.group == 'org.qi4j.library' )
      {
        from project.configurations.runtime
        into("libs/libraries/$project.name")
      }
      else if( project.group == 'org.qi4j.extension' )
      {
        from project.configurations.runtime
        into("libs/extensions/$project.name")
      }
    }
  }
  samplesImage = copySpec {
    into("samples")
    from "$projectDir/samples"
  }
  tutorialsImage = copySpec {
    into("tutorials")
    from "$projectDir/tutorials"
  }
  binDistImage = copySpec {
    into "qi4j-sdk-$version"
    with docsImage
    with reportsImage
    with javadocsImage
    with libsImage
    with samplesImage
    with tutorialsImage
  }
}

task zipSources(type: Zip) {
  with distLayout.srcDistImage
  classifier = 'src'
}

task tarSources(type: Tar) {
  with distLayout.srcDistImage
  classifier = 'src'
}

task zipBinaries(type: Zip, dependsOn: ['javadocs', 'test', 'distLayout']) {
  classifier = 'bin'
  with distLayout.binDistImage
}

task tarBinaries(type: Tar, dependsOn: ['javadocs', 'test', 'distLayout']) {
  classifier = 'bin'
  with distLayout.binDistImage
}

task uploadDists() {
  dependsOn zipSources
  dependsOn tarSources
  dependsOn zipBinaries
  dependsOn tarBinaries
  // TODO: Upload SDK ZIP and TAR to repository??
}

task release {
  description = 'Builds, tests and uploads the release artifacts'
  group = 'release'
  doFirst {
    if( System.properties[ 'version' ] == null )
    {
      throw new GradleException("'version' must be given as a system property to perform a release.")
    }
  }
  dependsOn allprojects*.uploadArchives
  dependsOn uploadDists
}

//
// This is a task that generates the gradlew scripts, allowing users to run gradle without having gradle installed
// on their system.
// This task should be run by "build master" and the resulting ouput committed to source control.  Its outputs include:
//  1) /gradlew which is the *NIX shell script for executing builds
//  2) /gradlew.bat which is the windows bat script for for executing builds
//  3) /wrapper which is a directory named by the "jarPath" config which contains other needed files.
task wrapper(type: Wrapper) {
  gradleVersion = '1.0-milestone-1'
  jarPath = 'wrapper'
}
