apply plugin: 'java'
apply from: 'maven-compat.gradle'
apply plugin: 'project-report'

// Versions of Dependencies;
asmVersion = '3.3'
bouncyVersion = '1.45'
googleCollectionsVersion = '1.0'
jdbmVersion = '1.0'
jettyVersion = '6.1.22'
jodaTimeVersion = '1.6.2'
log4jVersion = '1.2.16'
osgiVersion = '4.2.0'
rdfVersion = '2.3.2'
restletVersion = '2.0.4'
servletVersion = '2.5'
shiroVersion = '1.1.0'
sleepycatVersion = '4.0.103'
slf4jVersion = '1.6.1'
solrVersion = "1.4.1"
springVersion = '2.5.6'
strutsVersion = '2.1.8.1'
vaadinVersion = '6.4.8'
voldemortVersion = '0.81'

antVersion = '1.8.1'
junitVersion = '4.8.1'
testNgVersion = '5.8'
jmockVersion = '2.5.1'
mockitoVersion = '1.8.5'
easyMockVersion = '3.0'

targetCompatibility = "1.6"
sourceCompatibility = "1.6"

testFailures = false

allprojects {
  apply plugin: 'eclipse'
  apply plugin: 'idea'
  apply plugin: 'java'
  apply plugin: 'code-quality'
  apply plugin: 'project-report'

  defaultTasks 'build'
  version = System.properties.version ?: "0"
  idea.javaVersion = '1.6'
  [compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

  repositories {
    mavenCentral()
    mavenRepo name: 'ops4j-repo', urls: "http://repository.ops4j.org/maven2/"
  }

  dependencies {
    testCompile('org.apache.ant:ant:1.8.1')
    testCompile('junit:junit:4.8.1')
    testRuntime('net.sourceforge.cobertura:cobertura:1.9.3')
    testRuntime("asm:asm:$asmVersion", "asm:asm-util:$asmVersion", "asm:asm-commons:$asmVersion")
  }

  configurations {
    deployerJars
  }

  dependencies {
    deployerJars "org.apache.maven.wagon:wagon-ssh:1.0-beta-2"
  }

  uploadArchives {
    repositories.mavenDeployer {
      name = 'sshDeployer' // optional
      configuration = configurations.deployerJars
      repository(url: "scp://repository.ops4j.org/home/www/repository.ops4j.org/maven2")
    }
  }
  dependsOnChildren()
}

def testProperties = [
        'proxySet': System.properties[ 'proxySet' ],
        'proxyHost': System.properties[ 'proxyHost' ],
        'proxyPort': System.properties[ 'proxyPort' ]]

// build a map of the dependency artifacts to use.  Allows centralized definition of the version of artifacts to
// use.  In that respect it serves a role similar to <dependencyManagement> in Maven

libraries = [
        // Ant
        ant: "org.apache.ant:ant:$antVersion",

        // ASM
        asm: "asm:asm:$asmVersion",
        asm_util: "asm:asm-util:$asmVersion",
        asm_commons: "asm:asm-commons:$asmVersion",

        // OSGi
        osgi_core: "org.osgi:org.osgi.core:$osgiVersion",
        osgi_compendium: "org.osgi:org.osgi.compendium:$osgiVersion",
        osgi_enterprise: "org.osgi:org.osgi.enterprise:$osgiVersion",

        // logging
        slf4j_api: "org.slf4j:slf4j-api:$slf4jVersion",
        slf4j_simple: "org.slf4j:slf4j-simple:$slf4jVersion",
        jcl_slf4j: "org.slf4j:jcl-over-slf4j:$slf4jVersion",
        jcl_api: 'commons-logging:commons-logging-api:99.0-does-not-exist',  //ensure it is never used.
        jcl: 'commons-logging:commons-logging:99.0-does-not-exist',  // ensure it is never used.

        // testing
        junit: "junit:junit:$junitVersion",
        easymock: "org.easymock:easymock:$easyMockVersion",
        mockito: "org.mockito:mockito-core:$mockitoVersion",
        jmock: "org.jmock:jmock:$jmockVersion",
        testng: "org.testng:testng:$testNgVersion:jdk15"
]


subprojects { subProject ->

  print "$subProject  ->  "
  if( group.startsWith('qi4j-sdk.core') )
  {
    baseName = "qi4j-core-${subProject.name}"
    group = 'org.qi4j.core'
  }
  else if( group.startsWith('qi4j-sdk.libraries') )
  {
    baseName = "qi4j-lib" + (group - 'qi4j-sdk.libraries').replace('.', '-') + "-${subProject.name}"
    group = 'org.qi4j.library' + (group - 'qi4j-sdk.libraries')
  }
  else if( group.startsWith('qi4j-sdk.extensions') )
  {
    baseName = "qi4j-ext" + (group - 'qi4j-sdk.extensions').replace('.', '-') + "-${subProject.name}"
    group = 'org.qi4j.extension' + (group - 'qi4j-sdk.extensions')
  }
  else if( group.startsWith('qi4j-sdk.samples') )
  {
    baseName = "qi4j-sample-${subProject.name}"
    group = 'org.qi4j.sample'
  }
  else if( group.startsWith('qi4j-sdk.tools') )
  {
    baseName = "qi4j-tool-${subProject.name}"
    group = 'org.qi4j.tool'
  }
  else if( group.startsWith('qi4j-sdk.tutorials') )
  {
    baseName = "qi4j-tutorial-${subProject.name}"
    group = 'org.qi4j.tutorial'
  }
  else if( group.startsWith('qi4j-sdk.tests') )
  {
    baseName = "qi4j-tests-${subProject.name}"
    group = 'org.qi4j.tests'
  }
  else
  {
    baseName = "qi4j-${subProject.name}"
    group = 'org.qi4j'
  }
  print "group:$group,"
  print " name:${subProject.name},"
  print " artifact:$baseName,"
  println " version:$version"

  javaDir = new File(subProject.projectDir.absolutePath + "/src/main/java")
  testDir = new File(subProject.projectDir.absolutePath + "/src/test/java")

  if( javaDir.isDirectory() || testDir.isDirectory() )
  {
    apply plugin: 'osgi'
    apply plugin: VersionClass
    apply plugin: 'code-quality'

    if( subProject.name == "runtime" && subProject.group == "org.qi4j.core" )
    {
      checkstyleMain {
        configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-runtime-checkstyle.xml")
        ignoreFailures = true
      }
    }
    else
    {
      checkstyleMain {
        configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-api-checkstyle.xml")
        ignoreFailures = true
      }
    }
    checkstyleTest {
      configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-tests-checkstyle.xml")
      ignoreFailures = true
    }

    checkstyleVersion {
      configFile = new File("$rootProject.projectDir.absolutePath/etc/qi4j-tests-checkstyle.xml")
      ignoreFailures = true
    }

    jar {
      group = subProject.group
      baseName = subProject.baseName
      manifest {
        version = subProject.version
        license = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
        docURL = 'http://www.qi4j.org'
        description = 'Qi4j is a platform for Composite Oriented Programming'
        name = "$group.${subProject.name}"  // default name if forgotten in sub-project.
        vendor = 'Qi4j Community, http://www.qi4j.org'
        symbolicName = "$group.${subProject.name}"
        instruction '-debug', 'true'
      }
    }

    def cobSerFile = "${project.buildDir}/coverage/cobertura.ser"
    def srcOriginal = "${sourceSets.main.classesDir}"
    def srcCopy = "${srcOriginal}-copy"

    test.doFirst {
      ant {
        // delete data file for cobertura, otherwise coverage would be added
        delete(file: cobSerFile, failonerror: false)
        // delete copy of original classes
        delete(dir: srcCopy, failonerror: false)
        // import cobertura task, so it is available in the script
        taskdef(resource: 'tasks.properties', classpath: configurations.testRuntime.asPath)
        // create copy (backup) of original class files
        copy(todir: srcCopy) {
          fileset(dir: srcOriginal)
        }
        // instrument the relevant classes in-place
        'cobertura-instrument'(datafile: cobSerFile) {
          fileset(dir: srcOriginal,
                  includes: "org/qi4j/**/*.class",
                  excludes: "**/*Test.class")
        }
      }
    }

    test.doLast {
      if( new File(srcCopy).exists() )
      {
        def gradleProject = project
        def rootCobSerFile = "${rootProject.buildDir}/coverage/cobertura.ser"

        // replace instrumented classes with backup copy again
        ant {
          delete(file: srcOriginal)
          move(file: srcCopy, tofile: srcOriginal)

          taskdef(name: 'coberturaMerge',
                  classname: 'net.sourceforge.cobertura.ant.MergeTask',
                  classpath: configurations.testRuntime.asPath)

          coberturaMerge(datafile: rootCobSerFile) {

            if( file("${gradleProject.buildDir}/coverage/cobertura.ser").exists() )
            {

              fileset(dir: gradleProject.buildDir, includes: 'coverage/cobertura.ser')
            }
          }
        }
      }
    }

    test {
      maxHeapSize = "1024m"
      systemProperties = testProperties
      systemProperties[ "net.sourceforge.cobertura.datafile" ] = cobSerFile
      ignoreFailures = true
      afterSuite { descriptor, result ->
        if( result.testCount != result.successfulTestCount )
        {
          rootProject.testFailures = true
        }
      }
    }
  }

  uploadArchives.doFirst {
    if( System.properties[ 'version' ] == null )
      throw new GradleException("'version' must be given as a system property to perform a release.")
  }

  ideaModule {
    whenConfigured { module ->
      module.dependencies*.exported = true
    }
  }
}

build.doLast() {
//task genReport {
  def cobSerFile = "${project.buildDir}/coverage/cobertura.ser"
  println childProjects
  ant {
    taskdef(name: 'coberturaReport',
            classname: 'net.sourceforge.cobertura.ant.ReportTask',
            classpath: configurations.testRuntime.asPath)

    // create cobertura report
    coberturaReport(destdir: buildDirName + "/reports/cobertura", format: 'html', datafile: cobSerFile) {
      allprojects.each { module ->
        if( rootProject != module )
        {
          println module
          if( file("$module.projectDir.absolutePath/src/main/java").exists() )
          {
            fileset(dir: "$module.projectDir.absolutePath/src/main/java") {
              include(name: '**/*.java')
            }
          }
        }
      }
    }

    // create Junit report
    def junitReportDir = buildDirName + "/reports/junit"
    mkdir(dir: junitReportDir)
    mkdir(dir: buildDirName + "/test-results")
    'junitreport'(todir: junitReportDir) {
      report(format: 'frames', todir: junitReportDir)
      allprojects.each { module ->
        fileset(dir: "$module.buildDir/test-results") {
          include(name: "TEST-*.xml")
        }
      }
    }
  }
}

task javadocs(type: Javadoc) {
  def apiSources = subprojects.findAll({ project -> project.name != 'runtime' })
  source apiSources.collect { project ->
    project.sourceSets.main.allJava
  }
  destinationDir = new File("$buildDir", 'javadoc')
  // Might need a classpath
  classpath = files(apiSources.collect { project ->
    project.sourceSets.main.compileClasspath
  })
}

//
// This is a task that generates the gradlew scripts, allowing users to run gradle without having gradle installed
// on their system.
// This task should be run by "build master" and the resulting ouput committed to source control.  Its outputs include:
//  1) /gradlew which is the *NIX shell script for executing builds
//  2) /gradlew.bat which is the windows bat script for for executing builds
//  3) /wrapper which is a directory named by the "jarPath" config which contains other needed files.
task wrapper(type: Wrapper) {
  gradleVersion = '0.9.2'
  jarPath = 'wrapper'
}
