project.ext {
  title = "Qi4j SDK"
  description = "Qi4jâ„¢ is a framework for domain centric application development, including evolved concepts from AOP, DI and DDD."
  testFailures = [ ]
  mainClassName = 'org.qi4j.container.Main'
  groovycMain_mx = "512m"
  groovycMain_permSize = "128m"
  groovycMain_maxPermSize = "256m"
}


apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'signing'
apply plugin: 'maven'
apply from: 'maven-compat.gradle'
apply plugin: 'project-report'
apply from: 'libraries.gradle'

targetCompatibility = "1.6"
sourceCompatibility = "1.6"

// Collect the modules that fulfills the Release Criteria.
project.ext {
  releaseSpec = new org.qi4j.gradle.plugin.ModuleReleaseSpecification()
}

def releaseApprovedProjects = allprojects.findAll( { project ->  rootProject.ext.releaseSpec.satisfiedBy( project ) } )

buildscript {
  repositories {
    mavenCentral()
  }
}

idea.project.ipr {
  withXml { provider ->
    provider.node.component.find { it.@name == 'VcsDirectoryMappings' }.mapping.@vcs = 'Git'
  }
}


allprojects {
  apply plugin: 'eclipse'
  apply plugin: 'idea'
  apply plugin: 'signing'
  apply plugin: 'java'
//  apply plugin: 'checkstyle'
  apply plugin: 'project-report'
  apply plugin: 'maven'


  defaultTasks 'classes', 'test'

  group = name.substring( 0, name.lastIndexOf( '.' ) )
  version = System.properties.version ?: "0"
  [ compileJava, compileTestJava, javadoc ]*.options*.encoding = 'UTF-8'

  repositories {
    mavenCentral()
    mavenRepo name: 'ops4j-repo', url: "http://repository.ops4j.org/maven2/"
    mavenRepo name: 'aduna-repo', url: "http://repo.aduna-software.org/maven2/releases/"
    mavenRepo name: 'restlet-repo', url: 'http://maven.restlet.org'
    mavenRepo name: 'maven2-repository.dev.java.net', url: "http://download.java.net/maven/2"
  }

  // Artifact upload global configuration -----------------------------
  def uploadSnapshots = version.contains("SNAPSHOT")
  def uploadReleases = ! uploadSnapshots
  // By default RELEASES are signed, SNAPSHOTS are not
  // Signing can be turned on or off by setting the uploadSigned property
  def uploadSigned = rootProject.hasProperty('uploadSigned') \
                        ? rootProject.uploadSigned : uploadReleases \
                        ? true : false
  // By default RELEASES must satisfy ReleaseSpecification, SNAPSHOT don't
  // ReleaseSpecification usage can be turned on or off by setting the uploadReleaseSpec property
  def uploadReleaseSpec = rootProject.hasProperty('uploadReleaseSpec') \
                             ? rootProject.uploadReleaseSpec : uploadReleases \
                             ? true : false
  // By default RELEASES are uploaded using SSH, SNAPSHOTS using WEBDAV
  // Used Wagon can be overriden by setting the uploadWagon property
  def wagonSSH = "org.apache.maven.wagon:wagon-ssh:1.0-beta-2"
  def wagonWEBDAV = "org.apache.maven.wagon:wagon-webdav:1.0-beta-2"
  def uploadWagon = rootProject.hasProperty('uploadWagon') \
                        ? rootProject.uploadWagon : uploadReleases \
                        ? wagonSSH : wagonWEBDAV
  // By default RELEASES are uploaded to OPS4J, SNAPSHOTS to Cloudbees
  // Target repository can be overriden by setting the uploadRepository property
  def releasesRepository = "scp://repository.ops4j.org/home/www/repository.ops4j.org/maven2/"
  def snapshotsRepository = "dav:https://repository-qi4j.forge.cloudbees.com/snapshot/"
  def uploadRepository = rootProject.hasProperty('uploadRepository') \
                            ? rootProject.uploadRepository : uploadReleases \
                            ? releasesRepository : snapshotsRepository
  // No username/password is provided by default
  // If needed set them using the uploadUsername and uploadPassword properties
  def uploadUsername = rootProject.hasProperty('uploadUsername') ? rootProject.uploadUsername : null
  def uploadPassword = rootProject.hasProperty('uploadPassword') ? rootProject.uploadPassword : null


  configurations {
    archives
    deployerJars
    provided
    compile.extendsFrom provided
    runtime.extendsFrom compile
  }

  dependencies {
    testCompile( libraries.ant )
    testCompile( libraries.ant_junit )
    testCompile( libraries.junit )
    testRuntime( libraries.asm, libraries.asm_commons, libraries.asm_util )
    deployerJars( uploadWagon )
  }

  sourceSets {
    docs {
      resources {
        srcDir 'src/docs'
      }
    }
  }

  test.onlyIf { !project.hasProperty( 'skipTests' ) }

  project.ext {
    javaDir = new File( "$projectDir/src/main/java" )
    scalaDir = new File( "$projectDir/src/main/scala" )
    documenationDir = new File( "$projectDir/src/docs" )
    testDir = new File( "$projectDir/src/tests/java" )
  }

  if( ext.javaDir.isDirectory() || ext.scalaDir.isDirectory() || ext.testDir.isDirectory() )
  {
    apply plugin: 'osgi'
    apply plugin: VersionClass

//    if( name == "org.qi4j.core.runtime" )
//    {
//      checkstyleMain {
//        configFile = new File( "$rootProject.projectDir.absolutePath/etc/qi4j-runtime-checkstyle.xml" )
//        ignoreFailures = true
//      }
//    }
//    else
//    {
//      checkstyleMain {
//        configFile = new File( rootProject.projectDir.absolutePath.toString() + '/etc/qi4j-api-checkstyle.xml' )
//        ignoreFailures = true
//        reporting.baseDir = "$rootProject.reporting.baseDir/checkstyle"
//      }
//    }
//    checkstyleTest {
//      configFile = new File( "$rootProject.projectDir.absolutePath/etc/qi4j-tests-checkstyle.xml" )
//      ignoreFailures = true
//    }
//
//    checkstyleVersion {
//      configFile = new File( "$rootProject.projectDir.absolutePath/etc/qi4j-tests-checkstyle.xml" )
//      ignoreFailures = true
//    }

    jar {
      manifest {
        license = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
        docURL = 'http://www.qi4j.org'
        description = project.description ?: 'Qi4j is a platform for Composite Oriented Programming'
        vendor = 'Qi4j Community, http://www.qi4j.org'
        instruction '-debug', 'true'
      }
    }

    signing {
      required { uploadSigned }
      sign configurations.archives
    }

    task sourceJar( type: Jar ) {
      classifier = "sources"
      from sourceSets.main.allSource
    }

    task testSourceJar( type: Jar ) {
      classifier = "testsources"
      from sourceSets.test.allSource
    }

    task javadocJar( type: Jar ) {
      classifier = "javadoc"
      from javadoc.destinationDir
      dependsOn javadoc
    }

    artifacts {
      archives sourceJar, testSourceJar, javadocJar
    }

    def testProperties = [
            'proxySet': System.properties[ 'proxySet' ],
            'proxyHost': System.properties[ 'proxyHost' ],
            'proxyPort': System.properties[ 'proxyPort' ] ]

    test {
      maxHeapSize = "1024m"
      systemProperties = testProperties
      ignoreFailures = true
      testReport = false
      testResultsDir = file( "$rootProject.testResultsDir" )
      afterSuite { descriptor, result ->
        if( result.resultType == TestResult.ResultType.FAILURE )
        {
          rootProject.ext.testFailures = project
        }
      }
    }

    // TODO: Is there some better way to do this??
    // I could not find any way to get handles on DependencyArtifacts
    // See: http://www.gradle.org/docs/current/javadoc/org/gradle/api/artifacts/DependencyArtifact.html
    // It's easy to get handles on artifact files but not on their download url ...
    // I think it's simply not possible as when artifacts are available locally the underlying IVY resolver
    // won't try to search remote repositories and so won't resolve remote download URLs.
    // The only ways to provide a list of download urls would be to provide a Qi4j repository that proxy other ones
    // so that we have all needed artifacts in a center place, OR, to go down and instrument IVY directly but I'm not
    // even sure it would allows us to gather resoled download URLs.
    test << {
      def mavenDep = "<dependencies>\n\n"
      def depList = ""
      configurations.runtime.allDependencies.each { dep ->
        if( !dep.group.startsWith("org.qi4j") ) {
          depList = depList + "http://central.maven.org/maven2/" + dep.group.replace(".","/") + "/" + dep.name + "/" + dep.version + "/" + dep.name + "-" + dep.version + ".jar\n"
          mavenDep = mavenDep + "<dependency>\n"
          mavenDep = mavenDep + "  <groupId>$dep.group</groupId>\n"
          mavenDep = mavenDep + "  <artifactId>$dep.group</artifactId>\n"
          mavenDep = mavenDep + "  <version>$dep.group</version>\n"
          mavenDep = mavenDep + "</dependency>\n\n"
        }
      }
      mavenDep = mavenDep + "</dependencies>\n"

      def downloadsFile = new File( buildDir.toString(), "download.deps" )
      downloadsFile.text = depList

      def mavenDepDir = new File( buildDir.toString(), "maven" );
      mavenDepDir.mkdirs()
      def mavenDepFile = new File( mavenDepDir, "dependencies.xml" )
      mavenDepFile.text = mavenDep
    }

//    // Create checkstyle report
//    task checkstyleReport( type: Xslt, dependsOn: check ) {
//      source project.checkstyle.reportsDir
//      include '*.xml'
//      destDir = file( "build/reports/checkstyle/" )
//      extension = 'html'
//      stylesheetFile = file( "$rootProject.projectDir/etc/checkstyle-noframes.xsl" )
//    }
//

    task minBuild {
      dependsOn classes
      dependsOn test
    }
  }

  // Upload Archives - Artifact Deployment
  uploadArchives.doFirst {
    if( version == 0 )
    {
      throw new GradleException( "'version' must be given as a system property to perform a release." )
    }
  }

  uploadArchives.onlyIf { ( !uploadReleaseSpec || ( releaseApprovedProjects.contains( project ) || project == rootProject ) ) && !project.hasProperty( 'skipUpload' ) }
  uploadArchives {
    dependsOn check
    repositories.mavenDeployer {
      if( uploadSigned )
        beforeDeployment { MavenDeployment deployment -> signing.signPom( deployment ) }
      configuration = configurations.deployerJars
      repository(url: uploadRepository) {
        if( uploadUsername )
          authentication(userName: uploadUsername, password: uploadPassword)
      }
      snapshotRepository(url: uploadRepository) {
        if( uploadUsername )
          authentication(userName: uploadUsername, password: uploadPassword)
      }
    }
  }

  idea.module.iml {
    whenMerged { module ->
      module.dependencies*.exported = true
    }
  }
}

gradle.taskGraph.whenReady {taskGraph ->
  taskGraph.allTasks.last().doLast {
    if( rootProject.ext.testFailures )
    {
      println "\nTest failures in:"
      rootProject.ext.testFailures.each { project -> println "  " + project.name }
      throw new RuntimeException( "There was TEST FAILURES!! See list above." )
    }
  }
}

test {
  dependsOn subprojects*.test
  testReport = true
}

task javadocs( type: Javadoc ) {

  options.docFilesSubDirs = true
  options.encoding = "UTF-8"
  title = "${rootProject.title} ${version}"
  def apiSources = releaseApprovedProjects.findAll( { project ->

    ( project.name.startsWith( 'org.qi4j.core' ) &&
      !project.name.startsWith( 'org.qi4j.core.runtime' ) ) ||
    project.name.startsWith( 'org.qi4j.library' ) ||
    project.name.startsWith( 'org.qi4j.extension' )
  } )
  source apiSources.collect { project ->
    project.sourceSets.main.allJava
  }
  destinationDir = new File( "" + buildDir + '/docs/javadoc' )
  // Might need a classpath
  classpath = files( apiSources.collect { project ->
    project.sourceSets.main.compileClasspath
  } )
  options.links( "http://java.sun.com/j2se/1.6.0/docs/api" )
  options.group( [ "Core API": [ "org.qi4j.api", "org.qi4j.api.*", "org.qi4j.io", "org.qi4j.functional" ],
                         "Core Bootstrap": [ "org.qi4j.bootstrap" ],
                         "Core SPI": [ "org.qi4j.spi", "org.qi4j.spi.*" ],
                         "Libraries": [ "org.qi4j.library.*", "org.qi4j.logging", "org.qi4j.logging.*", "org.qi4j.lang.*" ],
                         "Extensions": [ "org.qi4j.entitystore.*", "org.qi4j.index.*", "org.qi4j.metrics.*", "org.qi4j.cache.*", "org.qi4j.migration", "org.qi4j.migration.*" ],
                         "Test Support": [ "org.qi4j.test", "org.qi4j.test.*" ]
                 ] )

}
task buildAll( dependsOn: [ javadocs, test, jar, subprojects*.assemble, ':org.qi4j.manual:manuals' ] ) {}

def srcDistImage = copySpec {
  from '.'
  exclude '**/build/'     // build output
  exclude '**/bin/'       // helper scripts
  exclude 'derby.log'     // Derby test garbage
  exclude '**/*.iml'      // IDEA files
  exclude 'org.qi4j.ipr'  // IDEA files
  exclude 'org.qi4j.iws'  // IDEA files
  exclude '**/out/*'       // build output
  exclude '**/.git/'      // git directories
  exclude '**/.git*'      // git files
  exclude '**/.gradle/'   // gradle management files
  into "qi4j-sdk-$version/src/"

}

def reportsDistImage = copySpec {
  from "$buildDir/reports"
  into( "docs/reports" )
}

def docsImage = copySpec {
  from "build/docs"
  from "manual/build/docs/website"
  into( "docs" )
}

def downloadListImage = copySpec {
  releaseApprovedProjects.collect { p ->
    from "$p.buildDir/download.deps"
    into( "libs/dependencies/" )
    rename 'download.deps', p.name + '.deps'
  }
}

def libsImage = copySpec {
  releaseApprovedProjects.collect { proj ->
    into( "libs/" ) {
      from proj.configurations.archives.artifacts.files
      exclude '**-testsources.jar'
      exclude '**-javadoc.jar'
      exclude '**/*.asc'
    }
  }
}

def samplesImage = copySpec {
  from( "$projectDir/samples" )
  from( "$projectDir/samples/*/build/docs/javadoc" )
  into( "samples" )
  exclude '**/*.iml'
  exclude '**/build/'     // build output
}

def tutorialsImage = copySpec {
  from( "$projectDir/tutorials" )
  exclude '**/build/'
  into( "tutorials" )
  from( "$projectDir/tutorials/*/build/docs/javadoc" )
  exclude '**/*.iml'
}

def binDistImage = copySpec {
  into "qi4j-sdk-$version"
  with docsImage
  with reportsDistImage
  with downloadListImage
  with libsImage
  with samplesImage
  with tutorialsImage
}

task zipSources( type: Zip, dependsOn: [ buildAll ] ) {
  baseName = 'qi4j-sdk'
  with srcDistImage
  classifier = 'src'
}

task tarSources( type: Tar, dependsOn: [ buildAll ] ) {
  baseName = 'qi4j-sdk'
  with srcDistImage
  compression = Compression.GZIP
  classifier = 'src'
}

task zipBinaries( type: Zip, dependsOn: [ buildAll ] ) {
  baseName = 'qi4j-sdk'
  classifier = 'bin'
  with binDistImage
}

task tarBinaries( type: Tar, dependsOn: [ buildAll ] ) {
  baseName = 'qi4j-sdk'
  classifier = 'bin'
  compression = Compression.GZIP
  with binDistImage
}

artifacts {
  archives zipSources, tarSources, zipBinaries, tarBinaries
}

task dist( type: Copy, dependsOn: install ) {
  with binDistImage
  into "$buildDir/dist"
}

task release {
  description = 'Builds, tests and uploads the release artifacts'
  group = 'release'
  doFirst {
    if( System.properties[ 'version' ] == null )
    {
      throw new GradleException( "'version' must be given as a system property to perform a release." )
    }
  }
  dependsOn allprojects*.uploadArchives, dist
}

//
// This is a task that generates the gradlew scripts, allowing users to run gradle without having gradle installed
// on their system.
// This task should be run by "build master" and the resulting ouput committed to source control.  Its outputs include:
//  1) /gradlew which is the *NIX shell script for executing builds
//  2) /gradlew.bat which is the windows bat script for for executing builds
//  3) /wrapper which is a directory named by the "jarPath" config which contains other needed files.
task wrapper( type: Wrapper ) {
  gradleVersion = '1.2'
}
